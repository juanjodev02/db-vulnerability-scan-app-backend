import { Injectable } from '@nestjs/common';
import { Response } from 'express';
import * as sql from 'mssql';
import {
  AnalysisResult,
  Anomaly,
  Database,
  Relation,
  Trigger,
} from './models/models.interface';

@Injectable()
export class AppService {
  constructor() {
    this.getConnection().then(() => {
      console.log('Conexi√≥n exitosa');
    });
  }

  async getConnection(): Promise<sql.ConnectionPool> {
    return sql.connect({
      user: 'sa',
      password: 'Auditoria2022!',
      server: 'localhost',
      port: 1433,
      options: {
        trustServerCertificate: true,
      },
    });
  }

  async getDatabases(): Promise<Database[]> {
    const sql = await this.getConnection();
    const res = await sql.query(
      'SELECT name, database_id, create_date FROM sys.databases;',
    );

    return res.recordset.map(({ name, database_id, create_date }) => ({
      name,
      id: database_id,
    }));
  }
  async analyzeDatabase(databaseId: number): Promise<AnalysisResult> {
    const database = await this.getDatabases();
    const relations = await this.getRelations(
      database.find((db) => db.id === databaseId).name,
    );
    const tables = await this.getDatabaseTables(
      database.find((db) => db.id === databaseId).name,
    );
    const anomalies = await this.getAnomalies(
      database.find((db) => db.id === databaseId).name,
    );
    const triggers = await this.getTriggers(
      database.find((db) => db.id === databaseId).name,
    );
    return {
      relations,
      tables,
      anomalies,
      triggers,
    };
  }

  async getDatabaseTables(databaseName: string): Promise<string[]> {
    const sql = await this.getConnection();
    const res = await sql.query(
      `USE ${databaseName}
      SELECT name
      FROM sys.tables`,
    );

    return res.recordset.map(({ name }) => name);
  }

  async getRelations(databaseName: string): Promise<Relation[]> {
    // get all tables in the database and get all relations between them
    const sql = await this.getConnection();
    const res = await sql.query(
      `
      use ${databaseName}
      SELECT
      fk.name 'FK Name',
      tp.name 'Parent table',
      cp.name, cp.column_id,
      tr.name 'Refrenced table',
      cr.name, cr.column_id,
      fk.delete_referential_action_desc onDelete,
      fk.update_referential_action_desc onUpdate
  FROM 
      sys.foreign_keys fk
  INNER JOIN 
      sys.tables tp ON fk.parent_object_id = tp.object_id
  INNER JOIN 
      sys.tables tr ON fk.referenced_object_id = tr.object_id
  INNER JOIN 
      sys.foreign_key_columns fkc ON fkc.constraint_object_id = fk.object_id
  INNER JOIN 
      sys.columns cp ON fkc.parent_column_id = cp.column_id AND fkc.parent_object_id = cp.object_id
  INNER JOIN 
      sys.columns cr ON fkc.referenced_column_id = cr.column_id AND fkc.referenced_object_id = cr.object_id
  ORDER BY
      tp.name, cp.column_id
`,
    );
    console.log(res.recordset);

    return res.recordset.map((data) => ({
      originTable: data['Parent table'],
      destinationTable: data['Refrenced table'],
      name: data['FK Name'],
      onDelete: data['onDelete'],
      onUpdate: data['onUpdate'],
    }));
  }

  async getAnomalies(databaseName: string): Promise<Anomaly[]> {
    const sql = await this.getConnection();
    const res = await sql.query(`
    USE ${databaseName}
    DBCC CHECKCONSTRAINTS
    `);

    return res.recordset.map((data) => ({
      relation: {
        originTable: data['Table'],
        destinationTable: data['Table'],
        name: data['Where'],
        onDelete: '',
        onUpdate: '',
      },
      description: `Constraint ${data['Constraint']} is violated`,
    }));
  }

  async getTriggers(databaseName: string): Promise<Trigger[]> {
    const sql = await this.getConnection();
    const res = await sql.query(`
    USE ${databaseName}

    SELECT * FROM sys.triggers;
    `);

    return res.recordset.map((data) => ({
      table: data['object_id'],
      actions: data['type_desc'].split(' '),
    }));
  }

  async downloadAnalysisJson(databaseId: number, res: Response): Promise<void> {
    const analysis = await this.analyzeDatabase(databaseId);
    // generate json file
    const json = JSON.stringify(analysis, null, 2);
    // download json file
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', 'attachment; filename=analysis.json');
    res.send(json);
  }
}
